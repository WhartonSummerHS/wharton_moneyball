---
title: "Module 1: Vectors and Workflow"
output: html_document
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, comment = "", prompt = TRUE, collapse = TRUE, tidy=TRUE, fig.align = "center")
```

## A Motivating Example

In Problem Set 0, we used R to save a single number and perform calculations. 

While this functionality may be exciting, we're ultimately going to be interested in analyzing large amounts of data.
Consider the table below which lists different statistics for several basketball players from the 2015-16 NBA regular season. 
The statistics are:

* field goal makes (FGM)
* field goal attempts (FGA)
* three point makes (TPM)
* three point attempts (TPA)
* free throw makes (FTM)
* free throw attempts (FTA)

<center>
```{r echo=FALSE, results='asis'}
library(simpletable)
my.data <- data.frame("PLAYER" = c("Stephen Curry", "John Wall", "Jimmy Butler", "James Harden", "Kevin Durant", "LeBron James", "Kristaps Porzingis", "Dirk Nowitzki", "Tim Duncan", "Andre Drummond"), stringsAsFactors = FALSE)
my.data[,"FGM"] <- c(805,572,470,710,698,737,498,373,215,552)
my.data[,"FGA"] <-c(1597,1349,1034,1617,1381,1416,1112,886,442,1061)
my.data[,"TPM"] <- c(402,115,64,236,186,87,126,81,0,2)
my.data[,"TPA"] <- c(887,327,206,657,480,282,342,243,2,6)
my.data[,"FTM"] <- c(363,272,395,720,447,359,250,201,92,208)
my.data[,"FTA"] <- c(400,344,475,837,498,491,280,240,131,586)
players <- my.data[,"PLAYER"]
fgm <- my.data[,"FGM"]
fga <- my.data[,"FGA"]
tpm <- my.data[,"TPM"]
tpa <- my.data[,"TPA"]
ftm <- my.data[,"FTM"]
fta <- my.data[,"FTA"] 

fgp <- fgm/fga
tpp <- tpm/tpa
ftp <- ftm/fta

names(fgm) <- players
names(fga) <- players
names(fgp) <- players
names(tpm) <- players
names(tpa) <- players
names(tpp) <- players
names(ftm) <- players
names(fta) <- players
names(ftp) <- players

tablecode(my.data, tabletype="zebra1")
```
</center>
How are we going to load this data into R? 

## Vectors

The fundamental unit of data storage in R is a **vector**, which is simply an ordered collection of data.
We can input each column in the above table as a **vector**. Luckily, many of R's functions act on these vectors, which allow us to do the same calculation on a lot of different values at once. 

### Creating vectors
To create a vector containing the field goal makes (FGM), we use the combine function `c()` and enter each number within the parantheses separated by commas.
In the code example below, we create a vector called `fgm` which contains the FGM statistics from each player in the table and then print it out.

```{r}
fgm <- c(805, 572, 470, 710, 698, 737, 498, 373, 215, 552)
fgm
```


**Exercise:** Create vectors `fga`, `tpm`, `tpa`, `ftm` and `fta` which contain the FGA, TMP, TPA, FTM, FTA statistics for each player respectively.
```{r, echo = FALSE}
fga <- c(1597,1349,1034,1617,1381,1416,1112,886,442,1061)
tpm <- c(402,115,64,236,186,87,126,81,0,2)
tpa <- c(887,327,206,657,480,282,342,243,2,6)
ftm <- c(363,272,395,720,447,359,250,201,92,208)
fta <- c(400,344,475,837,498,491,280,240,131,586)
```

In R, the elements of a vector do not necessarily have to numbers.
They can be character strings too. 
Below, we create a vector that contains the names of the players in the above table.
```{r}
players <- c("Stephen Curry", "John Wall", "Jimmy Butler", "James Harden", "Kevin Durant", "LeBron James", "Kristaps Porzingis", "Dirk Nowitzki", "Tim Duncan", "Andre Drummond")
```

Vectors can also contain what are known as logicals, but we will rarely if ever encounter such vectors in this course. It is important to note, however, that every element of a vector must be of the same type. That is, you cannot have a vector whose first element is a number and whose second element is a character string. 
Let's see what happens if we try:

```{r}
x <- c(23, 'LeBron')
```

In this example, R did not return an error.
However, if we print out `x`, we see that it has coerced the number 23 into a character string `` `23` ''. 

Later in the course, we will sometimes need to create a vector of evenly spaced numbers.
To do this, we use the `seq()` command.
If we need to create a vector of consecutive integers, we can use the `:` syntax.
Both are demonstrated below
```{r seq}
seq(from = 0, to = 1, by = 0.1)
seq(from = 0, to = 1, length = 11)
1:10
```
### Naming elements in a vector

We're nearly done loading all of the data into the R.
Now, we can start to summarize each column of the data and also start computing new statistics from the ones listed in the table above.
Before proceeding, we have one more organizational task.

We know that the first element of the vector `fgm` is Stephen Curry's FGM while the ninth element of `tpa` is the number of three point shots that Dirk Nowitzki attempted.
When we print out `fgm` or `tpa` for instance, R does not tell us which values correspond to which players.
```{r}
fgm
tpa
```
As we proceed with our analysis, it'll be useful to have *named* the elements of the vector.
We can do that with the `names()` function. 

```{r}
fgm
names(fgm) <- players
fgm
```
When we use `names()`, we put the vector whose elements we want to name in the parantheses and on the right-hand side of the `<-` we put a character vector of the same length as the vector we want to name containing the element names. 
In the example above, we set the names of `fgm` to be the elements of the vector `players`.

**Exercise** Name the elements of `fga`, `tpm`, `tpa`, `ftm` and `fta`.

### Vector Arithmetic

Once we have created a vector, we can perform calculations on each element of the vector with very straightforward syntax:
```{r}
fgm + 5
fgm/5
fgm^5
sqrt(fgm)
```

In each of these examples, we see that arithmetic proceeds *elements-wise*: `fgm + 5` added 5 to every element of `fgm` while `sqrt(fgm)` took the square root of every element in `fgm`.

In basketball, field goal percentage (FGP) is one of the simplest statistic we can use to summarize a player's ability to shoot the ball well.
FGP is defined as FGA/FGM.
We can use the vectors `fga` and `fgm` to create a new vector `fgp` that records each players' field goal percentage.

```{r}
fgp <- fgm/fga
fgp
```

To evaluate `fgm / fga`, R took the first element of `fgm` and divided it by the other first element of `fga` and so on.
In order for this to work, `fgm` and `fga` had to be the same length.
Technically, R is able to handle element-wise arithmetic when the vectors are not of the same length (this is known as recycling) but we will not get into it.
**For the purposes of this class, whenever you want to do element-wise arithmetic with two vectors, they need to be of the same length.**

To determine the length of a vector we can use the function `length()` as follows:
```{r}
length(fgm)
length(fga)
length(c(1,2,3))
```

**Exercise** Create vectors `tpp` and `ftp` which contain the three-point percentages (TPP) and free throw percentages (FTP) of the players in the table. If a player's field goal percentage, three point percentage, and free throw percentage exeed 50%, 40%, and 90%, respectively, they are said to belong to the [50-40-90 club](https://en.wikipedia.org/wiki/50–40–90_club). Did any of the players in the table above qualify for the 50-40-90 club?

## Vector Functions

Up to this point, we have seen how to perform element-wise arithmetic with vectors.
Now that we have created the vectors `fgp`, `ftp`, and `tpp` we can start to study the *distribution* of these datasets.
R has several functions that operate on entire vectors (i.e. single datasets) but not in an element-wise fashion.
Below are a couple of examples.
**Exercise** Try to describe what each of the functions below does
```{r}
sum(fgp)
mean(fgp)
sd(fgp)
min(fgp)
max(fgp)
median(fgp)
range(fgp)
length(fgp)
sort(fgp)
quantile(fgp)
summary(fgp)
```

<!-- 

Let's add a bunch of exercises, practicing vector arithmetic

-->

## Indexing

Up to this point, we have created, manipulated, and summarized vectors.
To do this, we took advantage of R's ability to operate on entire vectors at once.
But what if we wanted to look at only a few elements of the vectors? For example, what if we wanted to compute the difference in Stephen Curry's field goal percentage and Dirk Nowitzki's field goal percentage? 
To do this, we need a way to *extract* specific elements of a vector.
This is known as **subsetting** and is an **EXTREMELY** important aspect of R since it allows us to extract and modify specific elements of an object.

To subset vectors, we will use the single-bracket notation `[ ]`.
Between the brackets we will specify which elements we want to extract.
So to extract the first element of `fgm` we would execute `fgm[1]` and to extract the third element we would execute `fgm[3]`:
```{r}
fgm[1]
fgm[3]
```

If you look at the output, you'll see that when prints the value of `fgm[1]` or `fgm[3]`, the value is preceded by a `[1]`.
This is R's way of letting you know that it is printing out a vector.
So what is really happening under the hood when we subset a vector is that R is creating another temporary vector containing only the elements we wanted to subset.
However, if we look in our environment pane, we see that there is no additional vector, which means that R is not saving that temporary vector. 
We, of course, could save it using the assignment operator and modify the new vector as much as we want:


```{r}
x <- fgm[1]
y <- x + 3
```

Above, the first line of code subsets the first element of `fgm`, creating a temporary vector of length 1 containing the first element of `fgm,` and saves the result as `x`.
In the next line, it adds three to this value and saves the result as `y`.
Of course, if all we wanted to do was create a vector of length one containing only the value of three plus the first element of `fgm`, we could have done `y <- fgm[1] + 3`.

Here we see for the first time an example of R's order of operations: subsetting happens before operations like addition.
We will have a lot more to say about the order of operations a bit later.


We can also use our `[ ]` syntax to *modify* vectors.
For instance, suppose we made a mistake inputing the first number of `fgm`, while the rest are fine. We can change this using subsetting:
```{r}
fgm[1] <- 105
```

**Exercise:** Change the first element of `fgm` back to 805.

```{r, echo = FALSE}
fgm[1] <- 805
```
We are not limited to subsetting one element at a time.
In order to subset multiple elements, we put a vector between the brackets: 

```{r}
fgm[c(1, 3)]
fgm[1:2]
players[c(1, 3)]
```


We can also use names to subset vectors.
Instead of putting a number (or vector of numbers) between the bracket, we now put a character string (or vector of character strings) specifying the names of vector elements we want to subset.
```{r}
fgp["Stephen Curry"]
fgp[c("Stephen Curry", "Dirk Nowitzki")]
fgp["Stephen Curry"] - fgp["Dirk Nowitzki"]
```

## NBA Shooting Metrics

Of the ten players in the table above, we see that LeBron James had the highest field goal percentage.
As it turns out, during the 2015--16 season, DeAndre Jordan led the league in field goal percentage, making just over 70% of his shots.
Meanwhile, Steph Curry made just over 50% of his shots.
Does this mean that DeAndre Jordan is the better shooter than Curry?

One criticism of FGP is that it treats 2-point shots the same as 3-point shots.
As a result, the league leader in FGP is usually a center whose shots mostly come from near the rim.
[effective Field Goal Percentage](https://en.wikipedia.org/wiki/Effective_field_goal_percentage) is a statistic that adjusts FGP to account for the fact that a made 3-point shots is worth 50% more than a made 2-point shot. 
The formula for eFGP is
$$ \text{eFGP} = \frac{\text{FGM} + 0.5 \times \text{TPM}}{\text{FGA}}.$$
We can compute the effective field goal percentage of all ten players as follows
```{r}
efgp <- (fgm + 0.5 * tpm)/fga
efgp
```

We see now that Curry has the highest effective field goal percentage.
Before declaring Curry was the best shooter out of these ten players, though, we might pause and ask about free throws.
Both field goal percentage and effective field goal percentage totally ignore free throws.
One metric that accounts for all field goals, three pointers, and free throws is [true shooting percentage](https://en.wikipedia.org/wiki/True_shooting_percentage), whose formula is given by
$$
\text{TPS} = \frac{\text{PTS}}{2\times(\text{FGA} + 0.44\times \text{FTA})},
$$
where $\text{PTS} = \text{FTM} + 2 \times \text{FGM} + \text{TPM}$ is the number of points scored.

**Exercise** Create vectors `pts` and `tsp` for points scored (PTS) and true shooting percentage (TSP). Which player had the highest true shooting percentage?
```{r, echo = FALSE}
pts <- ftm + 2 * fgm + tpm
tps <- pts/(2 * (fga + 0.44 * fta))
```
<!-- compute effective field goal percentage here, points, and true shooting percentage -->


## R Scripts

Up to this point, we have been working strictly within the R console, proceeding line-by-line.
As our commands become more and more complex, you'll find that using the console can get pretty cramped.
And if you make a mistake in entering your code, you'll get an error and have to start all over again.
Plus, when we start a new session of R Studio, the console is cleared. How can we save the commands we typed into R? We do so using an **R Script**. An R Script is a file type which R recognizes as storing R commands and is saved as a .R file. R Scripts are useful as we can edit our code before sending it to be run in the console. 

We can start a new R Script by clicking on the top left symbol in R Studio and selecting "R Script".

![](figures/lecture1_fig1.png)


The untitled R Script will then appear in the top left hand box of R Studio.

![](figures/lecture1_fig2.png)


In the R Script, type the following:

```{}
2 * 3
x <- 4
sqrt(x)
```


Now our code is just sitting in the R Script. To run the code (that is, evalutate it in the console) we click the "Run" button in the top right of the script. This will run one line of code at a time - whichever line the cursor is on. Place your cursor on the first line and click "Run". Observe how `2 * 3` now appears in the console, as well as the output `6`.

![](figures/lecture1_fig3.png)


If we want to run multiple lines at once, we highlight them all and click "Run".

![](figures/lecture1_fig4.png)

Note in the above that we had to run `x <- 4` before `sqrt(x)`. We need to define our variables first and run this code in the console before performing calculations with those variables. The console can't "see" the script unless you run the code in the script. 

One very nice thing about RStudio's script editor is that it will highlight syntax errors with a red squiggly line and a red cross in the sidebar.
If you move your mouse over the line, a pop-up will appear that can help you diagnose the potential problem.

Another advantage of R scripts is thta you can add comments to your code, which are preceded by the pound sign / hash sign #. 
Comments are useful because they allow you to explain what your code is doing.

**Exercise**
Create a new R script called "module1.R"" which contains all of the code used to load the data from the table above and computing all of the vectors of shooting statistics.
Be sure to add some comments!






